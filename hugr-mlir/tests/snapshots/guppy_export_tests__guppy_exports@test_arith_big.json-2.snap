---
source: hugr-mlir/tests/guppy_export_tests.rs
description: /home/doug/code/hugr-mlir-develop/hugr-mlir/tests/guppy-exports/test_arith_big.json
expression: mlir_mod.as_operation()
input_file: hugr-mlir/tests/guppy-exports/test_arith_big.json
---
module {
  func.func private @arith(%arg0: memref<!hugr.closure>, %arg1: i6, %arg2: f64, %arg3: i6) -> index {
    %0 = llvm.mlir.constant(0.000000e+00 : f64) : f64
    %1 = llvm.mlir.constant(5.000000e+00 : f64) : f64
    %2 = llvm.mlir.constant(-8.000000e+00 : f64) : f64
    %3 = llvm.mlir.constant(0 : i64) : i64
    %4 = llvm.mlir.constant(1 : i64) : i64
    %5 = builtin.unrealized_conversion_cast %4 : i64 to index
    %6 = llvm.mlir.poison : f64
    %7 = llvm.mlir.poison : i6
    %8 = builtin.unrealized_conversion_cast %3 : i64 to index
    %9 = llvm.sitofp %arg1 : i6 to f64
    %10 = llvm.fdiv %9, %9  : f64
    %11 = llvm.intr.floor(%10)  : (f64) -> f64
    %12 = llvm.fadd %11, %11  : f64
    %13 = llvm.fcmp "ole" %12, %2 : f64
    %14 = llvm.select %13, %4, %3 : i1, i64
    %15 = llvm.trunc %14 : i64 to i32
    llvm.switch %15 : i32, ^bb1(%12, %arg1 : f64, i6) [
      1: ^bb4(%12, %arg1 : f64, i6)
    ]
  ^bb1(%16: f64, %17: i6):  // pred: ^bb0
    %18 = llvm.fcmp "ogt" %16, %1 : f64
    %19 = llvm.select %18, %4, %3 : i1, i64
    %20 = llvm.trunc %19 : i64 to i32
    cf.switch %20 : i32, [
      default: ^bb3(%8, %6, %7 : index, f64, i6),
      1: ^bb2
    ]
  ^bb2:  // pred: ^bb1
    %21 = llvm.trunc %4 : i64 to i32
    cf.switch %21 : i32, [
      default: ^bb3(%5, %6, %7 : index, f64, i6),
      1: ^bb3(%5, %16, %17 : index, f64, i6)
    ]
  ^bb3(%22: index, %23: f64, %24: i6):  // 3 preds: ^bb1, ^bb2, ^bb2
    %25 = builtin.unrealized_conversion_cast %22 : index to i64
    %26 = llvm.trunc %25 : i64 to i32
    cf.switch %26 : i32, [
      default: ^bb8(%5 : index),
      1: ^bb4(%23, %24 : f64, i6)
    ]
  ^bb4(%27: f64, %28: i6):  // 2 preds: ^bb0, ^bb3
    %29 = llvm.sitofp %28 : i6 to f64
    %30 = llvm.fmul %29, %29  : f64
    %31 = llvm.fcmp "oeq" %30, %0 : f64
    %32 = llvm.select %31, %4, %3 : i1, i64
    %33 = llvm.trunc %32 : i64 to i32
    cf.switch %33 : i32, [
      default: ^bb5,
      1: ^bb6(%5, %6, %7 : index, f64, i6)
    ]
  ^bb5:  // pred: ^bb4
    %34 = llvm.trunc %3 : i64 to i32
    cf.switch %34 : i32, [
      default: ^bb6(%8, %27, %28 : index, f64, i6),
      1: ^bb6(%8, %6, %7 : index, f64, i6)
    ]
  ^bb6(%35: index, %36: f64, %37: i6):  // 3 preds: ^bb4, ^bb5, ^bb5
    %38 = builtin.unrealized_conversion_cast %35 : index to i64
    %39 = llvm.trunc %38 : i64 to i32
    cf.switch %39 : i32, [
      default: ^bb7(%36, %37 : f64, i6),
      1: ^bb8(%8 : index)
    ]
  ^bb7(%40: f64, %41: i6):  // pred: ^bb6
    %42 = llvm.fsub %40, %40  : f64
    %43 = llvm.sitofp %41 : i6 to f64
    %44 = llvm.fcmp "olt" %42, %43 : f64
    %45 = llvm.select %44, %4, %3 : i1, i64
    %46 = llvm.trunc %45 : i64 to i32
    cf.switch %46 : i32, [
      default: ^bb8(%5 : index),
      1: ^bb8(%8 : index)
    ]
  ^bb8(%47: index):  // 4 preds: ^bb3, ^bb6, ^bb7, ^bb7
    %48 = builtin.unrealized_conversion_cast %47 : index to i64
    llvm.return %48 : i64
  }
  hugr.const @const_32 : i6 = 3 : i6
  hugr.const @const_37 : i6 = 8 : i6
  hugr.const @const_43 : i6 = 5 : i6
  hugr.const @const_69 : !hugr.sum<tuple<>, tuple<>> = #hugr.sum<1, #hugr.tuple : tuple<>> : !hugr.sum<tuple<>, tuple<>>
  hugr.const @const_57 : i6 = 0 : i6
  hugr.const @const_74 : i6 = 3 : i6
  hugr.const @const_84 : !hugr.sum<tuple<>, tuple<>> = #hugr.sum<0, #hugr.tuple : tuple<>> : !hugr.sum<tuple<>, tuple<>>
}

